{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  audio {\\n    &.disabled {\\n      &::-webkit-media-controls-play-button {\\n        pointer-events: none;\\n        opacity: 0.5;\\n      }\\n    }\\n    &:focus {\\n      outline: none;\\n    }\\n  }\\n\\n  & .recording {\\n    background: red;\\n  }\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport cn from 'classnames';\nimport styled from 'styled-components';\nimport axios from 'axios';\nimport Loading from './Loading';\nimport RecorderIcon from './RecorderIcon';\nimport { getRecorderId } from './helper';\n/*\n  Adaptation of react-media-recorder: https://github.com/0x006F/react-media-recorder/blob/master/src/index.ts\n*/\n\nvar RecorderErrors;\n\n(function (RecorderErrors) {\n  RecorderErrors[\"AbortError\"] = \"media_aborted\";\n  RecorderErrors[\"NotAllowedError\"] = \"permission_denied\";\n  RecorderErrors[\"NotFoundError\"] = \"no_specified_media_found\";\n  RecorderErrors[\"NotReadableError\"] = \"media_in_use\";\n  RecorderErrors[\"OverconstrainedError\"] = \"invalid_media_constraints\";\n  RecorderErrors[\"TypeError\"] = \"no_constraints\";\n  RecorderErrors[\"NONE\"] = \"\";\n  RecorderErrors[\"NO_RECORDER\"] = \"recorder_error\";\n})(RecorderErrors || (RecorderErrors = {}));\n\nvar StyledAudioWrapper = styled.section(_templateObject());\n\nvar Recorder = function Recorder(_ref) {\n  var onStop = _ref.onStop,\n      blobUrl = _ref.blobUrl,\n      listId = _ref.listId,\n      cardId = _ref.cardId,\n      fullDisable = _ref.fullDisable,\n      setDisableAll = _ref.setDisableAll,\n      playList = _ref.playList,\n      socket = _ref.socket,\n      title = _ref.title;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      hovering = _useState2[0],\n      setHovering = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      loading = _useState4[0],\n      setLoading = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      loop = _useState6[0],\n      setLoop = _useState6[1];\n\n  var mediaRecorderOptions = null; // for individual recorder components\n\n  var _useState7 = useState(false),\n      _useState8 = _slicedToArray(_useState7, 2),\n      disabledRecord = _useState8[0],\n      setDisableRecord = _useState8[1];\n\n  var _useState9 = useState(true),\n      _useState10 = _slicedToArray(_useState9, 2),\n      disabledStop = _useState10[0],\n      setDisableStop = _useState10[1];\n\n  var mediaRecorder = useRef(null);\n  var mediaChunks = useRef([]);\n  var mediaStream = useRef(null);\n\n  var _useState11 = useState('idle'),\n      _useState12 = _slicedToArray(_useState11, 2),\n      status = _useState12[0],\n      setStatus = _useState12[1];\n\n  var _useState13 = useState(blobUrl),\n      _useState14 = _slicedToArray(_useState13, 2),\n      mediaBlobUrl = _useState14[0],\n      setMediaBlobUrl = _useState14[1];\n\n  var _useState15 = useState('NONE'),\n      _useState16 = _slicedToArray(_useState15, 2),\n      error = _useState16[0],\n      setError = _useState16[1]; // set up basic variables for app\n\n\n  var getMediaStream = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var requiredMedia, stream;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (status !== 'acquiring_media') {\n              setStatus('acquiring_media');\n            }\n\n            requiredMedia = {\n              audio: true\n            };\n            _context.prev = 2;\n            _context.next = 5;\n            return window.navigator.mediaDevices.getUserMedia(requiredMedia);\n\n          case 5:\n            stream = _context.sent;\n            mediaStream.current = stream;\n\n            if (status !== 'idle') {\n              setStatus('idle');\n            }\n\n            _context.next = 14;\n            break;\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](2);\n\n            if (error !== _context.t0.name) {\n              setError(_context.t0.name);\n            }\n\n            if (status !== 'idle') {\n              setStatus('idle');\n            }\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 10]]);\n  })), []);\n  useEffect(function () {\n    if (!window.MediaRecorder) {\n      throw new Error('Unsupported Browser');\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\"The specified MIME type you supplied for MediaRecorder doesn't support this browser\");\n      }\n    }\n\n    function loadStream() {\n      return _loadStream.apply(this, arguments);\n    }\n\n    function _loadStream() {\n      _loadStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return getMediaStream();\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      return _loadStream.apply(this, arguments);\n    }\n\n    if (!mediaStream.current) {\n      loadStream();\n    }\n  }, [getMediaStream, mediaRecorderOptions]);\n  useEffect(function () {\n    console.log(status);\n  }, [status]);\n  useEffect(function () {\n    if (blobUrl && mediaBlobUrl !== blobUrl) {\n      setMediaBlobUrl(blobUrl);\n    }\n  }, [blobUrl]);\n\n  var startRecording = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              setDisableAll(true);\n              socket.emit('recording', {\n                recording: true\n              });\n              setDisableRecord(true);\n              setDisableStop(false);\n              setError('NONE');\n\n              if (mediaStream.current) {\n                _context3.next = 8;\n                break;\n              }\n\n              _context3.next = 8;\n              return getMediaStream();\n\n            case 8:\n              if (!mediaStream.current) {\n                _context3.next = 17;\n                break;\n              }\n\n              mediaRecorder.current = new MediaRecorder(mediaStream.current);\n              mediaRecorder.current.ondataavailable = onRecordingActive;\n              _context3.next = 13;\n              return onRecordingStop;\n\n            case 13:\n              mediaRecorder.current.onstop = _context3.sent;\n\n              mediaRecorder.current.onerror = function () {\n                setError('NO_RECORDER');\n                setStatus('idle');\n              };\n\n              mediaRecorder.current.start();\n              setStatus('recording');\n\n            case 17:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function startRecording() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  var onRecordingActive = function onRecordingActive(_ref4) {\n    var data = _ref4.data;\n    mediaChunks.current.push(data);\n  };\n\n  var onRecordingStop = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var blobProperty, blob, data, result, url;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              blobProperty = {\n                type: 'audio/wav'\n              };\n              blob = new Blob(mediaChunks.current, blobProperty);\n              data = new FormData();\n              data.append('soundBlob', blob, \"\".concat(title, \".wav\"));\n              _context4.next = 6;\n              return axios.post('/upload', data, {\n                headers: {\n                  'content-type': 'multipart/form-data'\n                }\n              });\n\n            case 6:\n              result = _context4.sent;\n              url = result && result.data || '';\n              setMediaBlobUrl(url);\n              onStop(url, cardId);\n              setStatus('stopped');\n\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function onRecordingStop() {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  var stopRecording = function stopRecording() {\n    if (mediaRecorder.current) {\n      setDisableAll(false);\n      socket.emit('recording', {\n        recording: false\n      });\n      setDisableRecord(false);\n      setDisableStop(true);\n      setStatus('stopping');\n      mediaRecorder.current.stop();\n    }\n  };\n\n  return /*#__PURE__*/React.createElement(StyledAudioWrapper, null, /*#__PURE__*/React.createElement(\"div\", {\n    id: \"buttons\"\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    disabled: disabledRecord || fullDisable || playList,\n    className: cn('record', {\n      recording: disabledRecord\n    }),\n    onClick: startRecording\n  }, \"Record\"), /*#__PURE__*/React.createElement(\"button\", {\n    className: \"stop\",\n    disabled: disabledStop,\n    onClick: stopRecording\n  }, \"Stop\"), /*#__PURE__*/React.createElement(\"label\", {\n    htmlFor: \"loop\"\n  }, \"Loop\"), /*#__PURE__*/React.createElement(\"input\", {\n    type: \"checkbox\",\n    onClick: function onClick() {\n      return setLoop(!loop);\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", null, mediaBlobUrl ? /*#__PURE__*/React.createElement(\"audio\", {\n    id: getRecorderId(listId, cardId, blobUrl),\n    className: cn({\n      disabled: fullDisable\n    }),\n    muted: fullDisable,\n    src: mediaBlobUrl,\n    controls: true,\n    loop: loop\n  }) : /*#__PURE__*/React.createElement(\"div\", {\n    onDrop: /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(e) {\n        var data, result, _url;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                e.preventDefault();\n\n                if (!(e.dataTransfer.files && e.dataTransfer.files.length > 0)) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                setLoading(true);\n                setDisableAll(true);\n                data = new FormData();\n                data.append('soundBlob', e.dataTransfer.files[0], e.dataTransfer.files[0].name);\n                _context5.next = 8;\n                return axios.post('/upload', data, {\n                  headers: {\n                    'content-type': 'multipart/form-data'\n                  }\n                });\n\n              case 8:\n                result = _context5.sent;\n                _url = result && result.data || '';\n\n                if (_url) {\n                  setMediaBlobUrl(_url);\n                  onStop(_url, cardId);\n                }\n\n                setLoading(false);\n                setDisableAll(false);\n\n              case 13:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      return function (_x) {\n        return _ref6.apply(this, arguments);\n      };\n    }(),\n    onDragOver: function onDragOver(e) {\n      e.preventDefault();\n\n      if (!hovering && e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n        setHovering(true);\n      }\n    },\n    onDragLeave: function onDragLeave(e) {\n      e.preventDefault();\n\n      if (hovering) {\n        setHovering(false);\n      }\n    },\n    className: cn(\"dropzone\", {\n      hovering: hovering\n    })\n  }, (loading || status === 'recording') && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"dropzoneStatus\"\n  }, status === 'recording' && /*#__PURE__*/React.createElement(RecorderIcon, null), loading && /*#__PURE__*/React.createElement(Loading, null)), \"Drop files here\")), error && error !== 'NONE' && /*#__PURE__*/React.createElement(\"span\", null, error)));\n};\n\nexport default Recorder;","map":{"version":3,"sources":["/Users/mfjvacas/Documents/Dev/GitHub/projects/mapstereo-client/components/Recorder.tsx"],"names":["React","useCallback","useEffect","useRef","useState","cn","styled","axios","Loading","RecorderIcon","getRecorderId","RecorderErrors","StyledAudioWrapper","section","Recorder","onStop","blobUrl","listId","cardId","fullDisable","setDisableAll","playList","socket","title","hovering","setHovering","loading","setLoading","loop","setLoop","mediaRecorderOptions","disabledRecord","setDisableRecord","disabledStop","setDisableStop","mediaRecorder","mediaChunks","mediaStream","status","setStatus","mediaBlobUrl","setMediaBlobUrl","error","setError","getMediaStream","requiredMedia","audio","window","navigator","mediaDevices","getUserMedia","stream","current","name","MediaRecorder","Error","mimeType","isTypeSupported","console","loadStream","log","startRecording","emit","recording","ondataavailable","onRecordingActive","onRecordingStop","onstop","onerror","start","data","push","blobProperty","type","blob","Blob","FormData","append","post","headers","result","url","stopRecording","stop","disabled","e","preventDefault","dataTransfer","files","length","items"],"mappings":"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","sourcesContent":["import React, {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  Dispatch,\n  SetStateAction,\n} from 'react';\nimport cn from 'classnames';\nimport styled from 'styled-components';\nimport axios from 'axios';\nimport Loading from './Loading';\nimport RecorderIcon from './RecorderIcon';\nimport { getRecorderId } from './helper';\n\n/*\n  Adaptation of react-media-recorder: https://github.com/0x006F/react-media-recorder/blob/master/src/index.ts\n*/\n\ntype StatusMessages =\n  | 'media_aborted'\n  | 'permission_denied'\n  | 'no_specified_media_found'\n  | 'media_in_use'\n  | 'invalid_media_constraints'\n  | 'no_constraints'\n  | 'recorder_error'\n  | 'idle'\n  | 'acquiring_media'\n  | 'delayed_start'\n  | 'recording'\n  | 'stopping'\n  | 'stopped';\n\nenum RecorderErrors {\n  AbortError = 'media_aborted',\n  NotAllowedError = 'permission_denied',\n  NotFoundError = 'no_specified_media_found',\n  NotReadableError = 'media_in_use',\n  OverconstrainedError = 'invalid_media_constraints',\n  TypeError = 'no_constraints',\n  NONE = '',\n  NO_RECORDER = 'recorder_error',\n}\n\ninterface Props {\n  onStop: (url: string, cardId: number) => void;\n  blobUrl: string;\n  listId?: number;\n  cardId?: number;\n  setDisableAll?: Dispatch<SetStateAction<boolean>>;\n  fullDisable?: boolean;\n  playList?: boolean;\n  socket?: SocketIOClient.Socket;\n  title?: string;\n}\n\nconst StyledAudioWrapper = styled.section`\n  audio {\n    &.disabled {\n      &::-webkit-media-controls-play-button {\n        pointer-events: none;\n        opacity: 0.5;\n      }\n    }\n    &:focus {\n      outline: none;\n    }\n  }\n\n  & .recording {\n    background: red;\n  }\n`;\n\nconst Recorder = ({\n  onStop,\n  blobUrl,\n  listId,\n  cardId,\n  fullDisable,\n  setDisableAll,\n  playList,\n  socket,\n  title,\n}: Props) => {\n  const [hovering, setHovering] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [loop, setLoop] = useState(false);\n  const mediaRecorderOptions = null;\n  // for individual recorder components\n  const [disabledRecord, setDisableRecord] = useState(false);\n  const [disabledStop, setDisableStop] = useState(true);\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\n  const mediaChunks = useRef<Blob[]>([]);\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [status, setStatus] = useState<StatusMessages>('idle');\n\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | null>(blobUrl);\n  const [error, setError] = useState<keyof typeof RecorderErrors>('NONE');\n\n  // set up basic variables for app\n  const getMediaStream = useCallback(async () => {\n    if (status !== 'acquiring_media') {\n      setStatus('acquiring_media');\n    }\n    const requiredMedia: MediaStreamConstraints = {\n      audio: true,\n    };\n    try {\n      const stream = await window.navigator.mediaDevices.getUserMedia(\n        requiredMedia\n      );\n      mediaStream.current = stream;\n      if (status !== 'idle') {\n        setStatus('idle');\n      }\n    } catch (e) {\n      if (error !== e.name) {\n        setError(e.name);\n      }\n      if (status !== 'idle') {\n        setStatus('idle');\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error('Unsupported Browser');\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          `The specified MIME type you supplied for MediaRecorder doesn't support this browser`\n        );\n      }\n    }\n\n    async function loadStream() {\n      await getMediaStream();\n    }\n\n    if (!mediaStream.current) {\n      loadStream();\n    }\n  }, [getMediaStream, mediaRecorderOptions]);\n\n  useEffect(() => {\n    console.log(status);\n  }, [status]);\n\n  useEffect(() => {\n    if (blobUrl && mediaBlobUrl !== blobUrl) {\n      setMediaBlobUrl(blobUrl);\n    }\n  }, [blobUrl]);\n\n  const startRecording = async () => {\n    setDisableAll(true);\n    socket.emit('recording', {\n      recording: true,\n    });\n    setDisableRecord(true);\n    setDisableStop(false);\n    setError('NONE');\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n\n    if (mediaStream.current) {\n      mediaRecorder.current = new MediaRecorder(mediaStream.current);\n\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n\n      mediaRecorder.current.onstop = await onRecordingStop;\n      mediaRecorder.current.onerror = () => {\n        setError('NO_RECORDER');\n        setStatus('idle');\n      };\n      mediaRecorder.current.start();\n      setStatus('recording');\n    }\n  };\n\n  const onRecordingActive = ({ data }: BlobEvent) => {\n    mediaChunks.current.push(data);\n  };\n\n  const onRecordingStop = async () => {\n    const blobProperty: BlobPropertyBag = { type: 'audio/wav' };\n    const blob = new Blob(mediaChunks.current, blobProperty);\n\n    const data = new FormData();\n    data.append('soundBlob', blob, `${title}.wav`);\n\n    const result = await axios.post('/upload', data, {\n      headers: { 'content-type': 'multipart/form-data' },\n    });\n\n    const url = (result && result.data) || '';\n\n    setMediaBlobUrl(url);\n    onStop(url, cardId);\n    setStatus('stopped');\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      setDisableAll(false);\n      socket.emit('recording', {\n        recording: false,\n      });\n      setDisableRecord(false);\n      setDisableStop(true);\n      setStatus('stopping');\n      mediaRecorder.current.stop();\n    }\n  };\n\n  return (\n    <StyledAudioWrapper>\n      {/* <canvas className=\"visualizer\" height=\"60px\"></canvas> */}\n      <div id=\"buttons\">\n        <button\n          disabled={disabledRecord || fullDisable || playList}\n          className={cn('record', {\n            recording: disabledRecord,\n          })}\n          onClick={startRecording}\n        >\n          Record\n        </button>\n        <button\n          className=\"stop\"\n          disabled={disabledStop}\n          onClick={stopRecording}\n        >\n          Stop\n        </button>\n        <label htmlFor=\"loop\">Loop</label>\n        <input type=\"checkbox\" onClick={() => setLoop(!loop)} />\n        <div>\n          {mediaBlobUrl ? (\n            <audio\n              id={getRecorderId(listId, cardId, blobUrl)}\n              className={cn({\n                disabled: fullDisable,\n              })}\n              muted={fullDisable}\n              src={mediaBlobUrl}\n              controls\n              loop={loop}\n            />\n          ) : (\n            <div\n              onDrop={async (e) => {\n                e.preventDefault();\n                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n                  setLoading(true);\n                  setDisableAll(true);\n                  const data = new FormData();\n                  data.append(\n                    'soundBlob',\n                    e.dataTransfer.files[0],\n                    e.dataTransfer.files[0].name\n                  );\n\n                  const result = await axios.post('/upload', data, {\n                    headers: { 'content-type': 'multipart/form-data' },\n                  });\n\n                  const url = (result && result.data) || '';\n\n                  if (url) {\n                    setMediaBlobUrl(url);\n                    onStop(url, cardId);\n                  }\n\n                  setLoading(false);\n                  setDisableAll(false);\n                }\n              }}\n              onDragOver={(e) => {\n                e.preventDefault();\n                if (!hovering && e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n                  setHovering(true);\n                }\n              }}\n              onDragLeave={(e) => {\n                e.preventDefault();\n                if (hovering) {\n                  setHovering(false);\n                }\n              }}\n              className={cn(\"dropzone\", {\n                hovering\n              })}\n            >\n              {(loading || status === 'recording' ) && (\n                <div className=\"dropzoneStatus\">\n                  { status === 'recording' && <RecorderIcon/>}\n                  { loading && <Loading />}\n                </div>\n              )}\n              Drop files here\n            </div>\n          )}\n        </div>\n        {error && error !== 'NONE' && <span>{error}</span>}\n      </div>\n    </StyledAudioWrapper>\n  );\n};\n\nexport default Recorder;\n"]},"metadata":{},"sourceType":"module"}